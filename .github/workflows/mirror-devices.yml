name: Mirror Package Sources

on:
  schedule:
    - cron: '0 3 * * 3'
  workflow_dispatch:
  workflow_call:

permissions:
  contents: write

concurrency:
  group: mirror-sources
  cancel-in-progress: false

jobs:
  # ===========================================================================
  # MIRROR: Check all sources from devices.yml, detect new/changed packages
  # Outputs a matrix of ONLY devices with actual new packages
  # ===========================================================================
  mirror:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.process.outputs.matrix }}
      has_updates: ${{ steps.process.outputs.has_updates }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Process all sources from devices.yml
        id: process
        run: |
          mkdir -p .trackers
          MATRIX="[]"

          # Iterate devices with sources
          DEVICE_IDS=$(yq -r '.devices[] | select(.sources != null) | select(.sources | length > 0) | .id' devices.yml)

          for device_id in $DEVICE_IDS; do
            source_distro=$(yq -r ".devices[] | select(.id == \"$device_id\") | .source_distro" devices.yml)
            SOURCE_COUNT=$(yq -r ".devices[] | select(.id == \"$device_id\") | .sources | length" devices.yml)
            DEVICE_HAS_NEW=false

            echo ""
            echo "=== Device: $device_id ($SOURCE_COUNT source(s)) ==="
            mkdir -p "new-pkgs-${device_id}"

            for idx in $(seq 0 $((SOURCE_COUNT - 1))); do
              source_id=$(yq -r ".devices[] | select(.id == \"$device_id\") | .sources[$idx].id" devices.yml)
              source_url=$(yq -r ".devices[] | select(.id == \"$device_id\") | .sources[$idx].url" devices.yml)
              source_type=$(yq -r ".devices[] | select(.id == \"$device_id\") | .sources[$idx].type" devices.yml)
              source_format=$(yq -r ".devices[] | select(.id == \"$device_id\") | .sources[$idx].format" devices.yml)

              echo "--- Source: $source_id ($source_type) ---"

              # Check for new commits
              COMMIT_TRACKER=".trackers/${source_id}-commit"
              LATEST_COMMIT=$(git ls-remote "$source_url" HEAD | cut -f1)
              STORED_COMMIT=""
              if [ -f "$COMMIT_TRACKER" ]; then
                STORED_COMMIT=$(cat "$COMMIT_TRACKER")
              fi

              if [ "$LATEST_COMMIT" == "$STORED_COMMIT" ]; then
                echo "  No new commits (${LATEST_COMMIT:0:12})"
                continue
              fi

              echo "  New commits: ${STORED_COMMIT:0:12} -> ${LATEST_COMMIT:0:12}"
              echo "$LATEST_COMMIT" > "$COMMIT_TRACKER"

              # Clone source
              CLONE_DIR="/tmp/source-${source_id}"
              git clone --depth 1 "$source_url" "$CLONE_DIR"

              # Find package pattern
              case "$source_format" in
                deb)    PATTERN="*.deb" ;;
                rpm)    PATTERN="*.rpm" ;;
                pacman) PATTERN="*.pkg.tar.*" ;;
                *)      PATTERN="*.deb" ;;
              esac

              # Load previous hashes
              HASH_TRACKER=".trackers/${source_id}-hashes"
              declare -A OLD_HASHES=()
              if [ -f "$HASH_TRACKER" ]; then
                while IFS='=' read -r name hash; do
                  [[ -z "$name" ]] && continue
                  OLD_HASHES["$name"]="$hash"
                done < "$HASH_TRACKER"
              fi

              > "${HASH_TRACKER}.new"
              NEW_COUNT=0

              # Build search path list:
              #   pool/<source_distro>/ — distro-specific packages
              #   pool/main/            — distro-agnostic packages (kernel, drivers, etc.)
              # If neither exists, search the whole clone (flat repo structure).
              SEARCH_DIRS=()
              [ -d "$CLONE_DIR/pool/$source_distro" ] && SEARCH_DIRS+=("$CLONE_DIR/pool/$source_distro")
              [ -d "$CLONE_DIR/pool/main" ]            && SEARCH_DIRS+=("$CLONE_DIR/pool/main")
              if [ ${#SEARCH_DIRS[@]} -eq 0 ]; then
                SEARCH_DIRS+=("$CLONE_DIR")
              else
                echo "  Searching: ${SEARCH_DIRS[*]#$CLONE_DIR/}"
              fi

              for f in $(find "${SEARCH_DIRS[@]}" -name "$PATTERN"); do
                filename=$(basename "$f")
                safename="${filename//:/_}"
                hash=$(sha256sum "$f" | cut -d' ' -f1)

                echo "${safename}=${hash}" >> "${HASH_TRACKER}.new"

                if [ "${OLD_HASHES[$safename]}" != "$hash" ]; then
                  cp "$f" "new-pkgs-${device_id}/$safename"
                  echo "  New/changed: $safename"
                  NEW_COUNT=$((NEW_COUNT + 1))
                fi
              done

              mv "${HASH_TRACKER}.new" "$HASH_TRACKER"
              rm -rf "$CLONE_DIR"

              if [ "$NEW_COUNT" -gt 0 ]; then
                DEVICE_HAS_NEW=true
                echo "  $NEW_COUNT new/changed package(s)"
              else
                echo "  All hashes match, no changes"
              fi
            done

            # Only add device to matrix if it has actual new packages
            if [ "$DEVICE_HAS_NEW" == "true" ]; then
              MATRIX=$(echo "$MATRIX" | jq -c ". + [{\"device_id\": \"$device_id\", \"source_distro\": \"$source_distro\"}]")
              echo ">>> $device_id has new packages, added to build matrix"
            else
              rm -rf "new-pkgs-${device_id}"
            fi
          done

          echo ""
          echo "=== Matrix: $MATRIX ==="

          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          if [ "$MATRIX" == "[]" ]; then
            echo "has_updates=false" >> $GITHUB_OUTPUT
          else
            echo "has_updates=true" >> $GITHUB_OUTPUT
          fi

      - name: Install artifact SDK
        if: steps.process.outputs.has_updates == 'true'
        run: npm install @actions/artifact

      - name: Export artifact runtime variables
        if: steps.process.outputs.has_updates == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            core.exportVariable('ACTIONS_RESULTS_URL', process.env['ACTIONS_RESULTS_URL'])
            core.exportVariable('ACTIONS_RUNTIME_URL', process.env['ACTIONS_RUNTIME_URL'])
            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env['ACTIONS_RUNTIME_TOKEN'])

      - name: Upload per-device package artifacts
        if: steps.process.outputs.has_updates == 'true'
        run: |
          node --input-type=module << 'SCRIPT'
          import {DefaultArtifactClient} from '@actions/artifact'
          import {readdirSync, statSync} from 'fs'
          import {resolve} from 'path'

          const client = new DefaultArtifactClient()
          const dirs = readdirSync('.').filter(d =>
            d.startsWith('new-pkgs-') && statSync(d).isDirectory()
          )

          for (const dir of dirs) {
            const deviceId = dir.replace('new-pkgs-', '')
            const files = []
            const walk = (d) => {
              for (const entry of readdirSync(d, {withFileTypes: true})) {
                const full = resolve(d, entry.name)
                if (entry.isDirectory()) walk(full)
                else files.push(full)
              }
            }
            walk(dir)

            if (files.length > 0) {
              console.log(`Uploading mirror-${deviceId}: ${files.length} file(s)`)
              const {id, size} = await client.uploadArtifact(`mirror-${deviceId}`, files, dir)
              console.log(`  -> artifact id=${id} size=${size}`)
            }
          }
          SCRIPT

      - name: Upload tracker data
        uses: actions/upload-artifact@v4
        with:
          name: mirror-trackers
          path: .trackers/*
          if-no-files-found: ignore
          retention-days: 1

  # ===========================================================================
  # UPDATE REPO: Convert and publish (only for devices with new packages)
  # ===========================================================================
  update-repo:
    needs: mirror
    if: needs.mirror.outputs.has_updates == 'true'
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.mirror.outputs.matrix) }}
    uses: ./.github/workflows/update-repos.yml
    with:
      artifact_pattern: mirror-${{ matrix.device_id }}
      source_distro: ${{ matrix.source_distro }}
      device: ${{ matrix.device_id }}
      force_rebuild: false
    secrets:
      GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}

  # ===========================================================================
  # SAVE TRACKERS: Update tracker files on main branch
  # ===========================================================================
  save-trackers:
    needs: [mirror, update-repo]
    if: "!cancelled() && needs.mirror.result == 'success'"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Download tracker data
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: mirror-trackers
          path: .trackers/

      - name: Save trackers to main
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .trackers/
          git commit -m "Update mirror trackers" || echo "No changes to commit"
          git push origin main

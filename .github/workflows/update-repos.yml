name: Update Package Repositories

on:
  workflow_call:
    inputs:
      artifact_pattern:
        type: string
        default: 'pkg-*'
        description: 'Pattern to download build artifacts'
      source_distro:
        type: string
        default: 'noble'
        description: 'Codename of the source distro the packages were built on'
    secrets:
      GPG_PRIVATE_KEY:
        required: true

permissions:
  contents: write

jobs:
  publish:
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: ${{ inputs.artifact_pattern }}
          merge-multiple: true

      - name: Check for packages
        id: check
        run: |
          HAS_PKGS=false
          ls *.pkg.tar 1>/dev/null 2>&1 && HAS_PKGS=true
          ls *.deb 1>/dev/null 2>&1 && HAS_PKGS=true
          ls *.rpm 1>/dev/null 2>&1 && HAS_PKGS=true
          ls *.pkg.tar.zst 1>/dev/null 2>&1 && HAS_PKGS=true
          ls *.pkg.tar.xz 1>/dev/null 2>&1 && HAS_PKGS=true

          echo "has_pkgs=$HAS_PKGS" >> $GITHUB_OUTPUT
          if [[ "$HAS_PKGS" == "true" ]]; then
            echo "=== Downloaded packages ==="
            ls -la *.pkg.tar *.deb *.rpm *.pkg.tar.zst *.pkg.tar.xz 2>/dev/null || true
          else
            echo "No packages to publish"
          fi

      - name: Set up QEMU
        if: steps.check.outputs.has_pkgs == 'true'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64,arm

      - name: Checkout gh-pages
        if: steps.check.outputs.has_pkgs == 'true'
        run: |
          git fetch origin gh-pages:gh-pages || true
          git worktree add gh-pages-dir gh-pages || {
            git worktree add --detach gh-pages-dir
            cd gh-pages-dir
            git checkout --orphan gh-pages
            git rm -rf . 2>/dev/null || true
            cd ..
          }
          mkdir -p gh-pages-dir/apt/pool/main
          mkdir -p gh-pages-dir/dnf
          mkdir -p gh-pages-dir/pacman

      - name: Install tools
        if: steps.check.outputs.has_pkgs == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev apt-utils rpm createrepo-c libarchive-tools zstd

      - name: Import GPG key
        if: steps.check.outputs.has_pkgs == 'true'
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          gpg --armor --export "AstralEmu Packages" > gh-pages-dir/apt/astralemu.gpg
          mkdir -p gh-pages-dir/dnf
          cp gh-pages-dir/apt/astralemu.gpg gh-pages-dir/dnf/astralemu.gpg

      # ================================================================
      # NORMALIZE: Convert all inputs to intermediate format
      # ================================================================
      - name: Normalize all packages to intermediate format
        if: steps.check.outputs.has_pkgs == 'true'
        id: normalize
        run: |
          chmod +x scripts/pkg-extract.sh scripts/pkg-build-deb.sh scripts/pkg-build-rpm.sh scripts/pkg-build-pacman.sh scripts/resolve-deps.sh

          SOURCE_DISTRO="${{ inputs.source_distro }}"
          SCRIPT_DIR="$(pwd)/scripts"
          mkdir -p intermediates

          PKG_INDEX=0

          # 1) .pkg.tar = already intermediate, just extract
          for f in *.pkg.tar; do
            [[ -f "$f" ]] || continue
            INTDIR="intermediates/pkg-${PKG_INDEX}"
            mkdir -p "$INTDIR"
            tar xf "$f" -C "$INTDIR"
            echo "  [INT] $(cat "$INTDIR/meta/name") from $f"
            PKG_INDEX=$((PKG_INDEX + 1))
          done

          # 2) .deb = extract via pkg-extract.sh
          for f in *.deb; do
            [[ -f "$f" ]] || continue
            INTDIR="intermediates/pkg-${PKG_INDEX}"
            "$SCRIPT_DIR/pkg-extract.sh" "$f" "$INTDIR" --source-distro "$SOURCE_DISTRO"
            PKG_INDEX=$((PKG_INDEX + 1))
          done

          # 3) .rpm = extract via pkg-extract.sh
          for f in *.rpm; do
            [[ -f "$f" ]] || continue
            INTDIR="intermediates/pkg-${PKG_INDEX}"
            "$SCRIPT_DIR/pkg-extract.sh" "$f" "$INTDIR" --source-distro "$SOURCE_DISTRO"
            PKG_INDEX=$((PKG_INDEX + 1))
          done

          # 4) .pkg.tar.zst / .pkg.tar.xz = extract via pkg-extract.sh
          for f in *.pkg.tar.zst *.pkg.tar.xz; do
            [[ -f "$f" ]] || continue
            INTDIR="intermediates/pkg-${PKG_INDEX}"
            "$SCRIPT_DIR/pkg-extract.sh" "$f" "$INTDIR" --source-distro "$SOURCE_DISTRO"
            PKG_INDEX=$((PKG_INDEX + 1))
          done

          echo "=== Normalized $PKG_INDEX packages ==="

          # Detect architectures from intermediates
          ARCHES=""
          for intdir in intermediates/pkg-*; do
            [[ -d "$intdir/meta" ]] || continue
            A=$(cat "$intdir/meta/arch")
            ARCHES="$ARCHES $A"
          done
          ARCHES=$(echo "$ARCHES" | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          echo "arches=$ARCHES" >> $GITHUB_OUTPUT
          echo "Detected architectures: $ARCHES"
          echo "count=$PKG_INDEX" >> $GITHUB_OUTPUT

      # ================================================================
      # APT REPOSITORIES
      # ================================================================
      - name: Build APT repositories
        if: steps.check.outputs.has_pkgs == 'true'
        run: |
          SCRIPT_DIR="$(pwd)/scripts"
          DEP_MAP="$SCRIPT_DIR/dep-map.conf"
          SOURCE_DISTRO="${{ inputs.source_distro }}"
          APT_IDS=$(yq -r '.distros.apt[].id' distros.yml)

          for arch in ${{ steps.normalize.outputs.arches }}; do
            DEB_ARCH="$arch"
            case "$arch" in
              aarch64) DEB_ARCH="arm64" ;;
              x86_64)  DEB_ARCH="amd64" ;;
              armhf)   DEB_ARCH="armhf" ;;
            esac

            for distro_id in $APT_IDS; do
              echo "=== APT: $distro_id / $DEB_ARCH ==="
              POOL_DIR="gh-pages-dir/apt/pool/${distro_id}"
              mkdir -p "$POOL_DIR"
              mkdir -p "gh-pages-dir/apt/dists/${distro_id}/main/binary-${DEB_ARCH}"

              if [[ "$distro_id" == "$SOURCE_DISTRO" ]]; then
                # Source distro: build .debs with original deps
                for intdir in intermediates/pkg-*; do
                  [[ -d "$intdir/meta" ]] || continue
                  [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
                  "$SCRIPT_DIR/pkg-build-deb.sh" "$intdir" "$POOL_DIR/" \
                    --dep-map "$DEP_MAP" || \
                    echo "WARNING: Failed to build deb from $(basename "$intdir")"
                done
              else
                # Non-source distro: resolve deps first, then rebuild with mapping
                # Step 1: build temp .debs for dep scanning
                TEMP_POOL=$(mktemp -d)
                for intdir in intermediates/pkg-*; do
                  [[ -d "$intdir/meta" ]] || continue
                  [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
                  "$SCRIPT_DIR/pkg-build-deb.sh" "$intdir" "$TEMP_POOL/" \
                    --dep-map "$DEP_MAP" 2>/dev/null || true
                done

                # Step 2: resolve deps → prefixed packages + dep-mapping.txt
                FETCH_DIR="fetched-deps-apt-${distro_id}-${arch}"
                mkdir -p "$FETCH_DIR"
                "$SCRIPT_DIR/resolve-deps.sh" \
                  --source-pkgs "$TEMP_POOL" \
                  --source-distro "$SOURCE_DISTRO" \
                  --target-distro "$distro_id" \
                  --target-format deb \
                  --distros-config distros.yml \
                  --dep-map "$DEP_MAP" \
                  --output-dir "$FETCH_DIR" \
                  --arch "$arch" || echo "WARNING: dep resolution had errors for $distro_id"

                # Step 3: copy prefixed dep packages to pool
                for fetched in "$FETCH_DIR"/*.deb; do
                  [[ -f "$fetched" ]] || continue
                  cp "$fetched" "$POOL_DIR/"
                done

                # Step 4: rebuild our packages with deps updated from mapping
                MAPPING="$FETCH_DIR/dep-mapping.txt"
                for intdir in intermediates/pkg-*; do
                  [[ -d "$intdir/meta" ]] || continue
                  [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue

                  INTCOPY=$(mktemp -d)
                  cp -a "$intdir"/* "$INTCOPY/"

                  if [[ -s "$MAPPING" ]]; then
                    while IFS='=' read -r orig prefixed; do
                      [[ -z "$orig" ]] && continue
                      sed -i "s/^${orig}$/${prefixed}/" "$INTCOPY/meta/depends" 2>/dev/null || true
                    done < "$MAPPING"
                  fi

                  "$SCRIPT_DIR/pkg-build-deb.sh" "$INTCOPY" "$POOL_DIR/" \
                    --dep-map "$DEP_MAP" || \
                    echo "WARNING: Failed to rebuild deb for $distro_id"
                  rm -rf "$INTCOPY"
                done

                rm -rf "$TEMP_POOL"
              fi
            done

            # Generate Packages index per distro
            cd gh-pages-dir/apt
            for distro_id in $APT_IDS; do
              mkdir -p "dists/${distro_id}/main/binary-${DEB_ARCH}"
              dpkg-scanpackages --arch "$DEB_ARCH" "pool/${distro_id}" > "dists/${distro_id}/main/binary-${DEB_ARCH}/Packages" 2>/dev/null || true
              gzip -k -f "dists/${distro_id}/main/binary-${DEB_ARCH}/Packages"
            done
            cd ../..
          done

          # Generate Release + sign for each distro
          for distro_id in $APT_IDS; do
            cd "gh-pages-dir/apt/dists/${distro_id}"

            ARCH_LIST=$(ls -d main/binary-* 2>/dev/null | sed 's|main/binary-||' | tr '\n' ' ')

            cat > Release << RELEASE_EOF
          Origin: AstralEmu Packages
          Label: astralemu
          Suite: ${distro_id}
          Codename: ${distro_id}
          Architectures: ${ARCH_LIST}
          Components: main
          Description: AstralEmu packages for ${distro_id}
          RELEASE_EOF

            apt-ftparchive release . >> Release
            rm -f Release.gpg InRelease
            gpg --batch --default-key "AstralEmu Packages" -abs -o Release.gpg Release
            gpg --batch --default-key "AstralEmu Packages" --clearsign -o InRelease Release
            cd ../../../..
          done

      # ================================================================
      # DNF REPOSITORIES
      # ================================================================
      - name: Build DNF repositories
        if: steps.check.outputs.has_pkgs == 'true'
        run: |
          SCRIPT_DIR="$(pwd)/scripts"
          DEP_MAP="$SCRIPT_DIR/dep-map.conf"
          SOURCE_DISTRO="${{ inputs.source_distro }}"
          DNF_IDS=$(yq -r '.distros.dnf[].id' distros.yml)

          for arch in ${{ steps.normalize.outputs.arches }}; do
            RPM_ARCH="$arch"
            case "$arch" in
              aarch64) RPM_ARCH="aarch64" ;;
              x86_64)  RPM_ARCH="x86_64" ;;
              armhf)   RPM_ARCH="armv7hl" ;;
            esac

            for distro_id in $DNF_IDS; do
              VERSION=$(yq -r ".distros.dnf[] | select(.id == \"$distro_id\") | .version" distros.yml)
              echo "=== DNF: $distro_id ($VERSION) / $RPM_ARCH ==="
              RPM_DIR="gh-pages-dir/dnf/${VERSION}/${RPM_ARCH}"
              mkdir -p "$RPM_DIR"

              # Build temp .rpms for dep scanning
              TEMP_RPM=$(mktemp -d)
              for intdir in intermediates/pkg-*; do
                [[ -d "$intdir/meta" ]] || continue
                [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
                "$SCRIPT_DIR/pkg-build-rpm.sh" "$intdir" "$TEMP_RPM/" \
                  --dep-map "$DEP_MAP" 2>/dev/null || true
              done

              # Resolve deps → prefixed .rpms + dep-mapping.txt
              FETCH_DIR="fetched-deps-dnf-${distro_id}-${arch}"
              mkdir -p "$FETCH_DIR"
              "$SCRIPT_DIR/resolve-deps.sh" \
                --source-pkgs "$TEMP_RPM" \
                --source-distro "$SOURCE_DISTRO" \
                --target-distro "$distro_id" \
                --target-format rpm \
                --distros-config distros.yml \
                --dep-map "$DEP_MAP" \
                --output-dir "$FETCH_DIR" \
                --arch "$arch" || echo "WARNING: dep resolution had errors for $distro_id"

              # Copy prefixed dep packages
              for fetched in "$FETCH_DIR"/*.rpm; do
                [[ -f "$fetched" ]] || continue
                cp "$fetched" "$RPM_DIR/"
              done

              # Rebuild our packages with mapping applied
              MAPPING="$FETCH_DIR/dep-mapping.txt"
              for intdir in intermediates/pkg-*; do
                [[ -d "$intdir/meta" ]] || continue
                [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue

                INTCOPY=$(mktemp -d)
                cp -a "$intdir"/* "$INTCOPY/"

                if [[ -s "$MAPPING" ]]; then
                  while IFS='=' read -r orig prefixed; do
                    [[ -z "$orig" ]] && continue
                    sed -i "s/^${orig}$/${prefixed}/" "$INTCOPY/meta/depends" 2>/dev/null || true
                  done < "$MAPPING"
                fi

                "$SCRIPT_DIR/pkg-build-rpm.sh" "$INTCOPY" "$RPM_DIR/" \
                  --dep-map "$DEP_MAP" || \
                  echo "WARNING: Failed to rebuild RPM for $distro_id"
                rm -rf "$INTCOPY"
              done

              rm -rf "$TEMP_RPM"

              # Generate repodata
              if ls "gh-pages-dir/dnf/${VERSION}/${RPM_ARCH}/"*.rpm 1>/dev/null 2>&1; then
                createrepo_c "gh-pages-dir/dnf/${VERSION}/${RPM_ARCH}/"
                gpg --batch --default-key "AstralEmu Packages" -abs \
                  -o "gh-pages-dir/dnf/${VERSION}/${RPM_ARCH}/repodata/repomd.xml.asc" \
                  "gh-pages-dir/dnf/${VERSION}/${RPM_ARCH}/repodata/repomd.xml"
              fi
            done
          done

          # Create .repo config
          cat > gh-pages-dir/dnf/astralemu.repo << 'REPO_EOF'
          [astralemu]
          name=AstralEmu Packages
          baseurl=https://astralemu.github.io/astralemu-packages/dnf/$releasever/$basearch/
          enabled=1
          gpgcheck=1
          gpgkey=https://astralemu.github.io/astralemu-packages/dnf/astralemu.gpg
          REPO_EOF

      # ================================================================
      # PACMAN REPOSITORIES
      # ================================================================
      - name: Build Pacman repositories
        if: steps.check.outputs.has_pkgs == 'true'
        run: |
          SCRIPT_DIR="$(pwd)/scripts"
          DEP_MAP="$SCRIPT_DIR/dep-map.conf"
          SOURCE_DISTRO="${{ inputs.source_distro }}"

          for arch in ${{ steps.normalize.outputs.arches }}; do
            PAC_ARCH="$arch"
            case "$arch" in
              aarch64) PAC_ARCH="aarch64" ;;
              x86_64)  PAC_ARCH="x86_64" ;;
              armhf)   PAC_ARCH="armv7h" ;;
            esac

            echo "=== Pacman: $PAC_ARCH ==="
            PAC_DIR="gh-pages-dir/pacman/${PAC_ARCH}"
            mkdir -p "$PAC_DIR"

            # Build temp packages for dep scanning
            TEMP_PAC=$(mktemp -d)
            for intdir in intermediates/pkg-*; do
              [[ -d "$intdir/meta" ]] || continue
              [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
              "$SCRIPT_DIR/pkg-build-pacman.sh" "$intdir" "$TEMP_PAC/" \
                --dep-map "$DEP_MAP" 2>/dev/null || true
            done

            # Resolve deps → prefixed .pkg.tar.zst + dep-mapping.txt
            FETCH_DIR="fetched-deps-pacman-${arch}"
            mkdir -p "$FETCH_DIR"
            "$SCRIPT_DIR/resolve-deps.sh" \
              --source-pkgs "$TEMP_PAC" \
              --source-distro "$SOURCE_DISTRO" \
              --target-distro arch \
              --target-format pacman \
              --distros-config distros.yml \
              --dep-map "$DEP_MAP" \
              --output-dir "$FETCH_DIR" \
              --arch "$arch" || echo "WARNING: dep resolution had errors for pacman"

            # Copy prefixed dep packages
            for fetched in "$FETCH_DIR"/*.pkg.tar.zst; do
              [[ -f "$fetched" ]] || continue
              cp "$fetched" "$PAC_DIR/"
            done

            # Rebuild our packages with mapping applied
            MAPPING="$FETCH_DIR/dep-mapping.txt"
            for intdir in intermediates/pkg-*; do
              [[ -d "$intdir/meta" ]] || continue
              [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue

              INTCOPY=$(mktemp -d)
              cp -a "$intdir"/* "$INTCOPY/"

              if [[ -s "$MAPPING" ]]; then
                while IFS='=' read -r orig prefixed; do
                  [[ -z "$orig" ]] && continue
                  sed -i "s/^${orig}$/${prefixed}/" "$INTCOPY/meta/depends" 2>/dev/null || true
                done < "$MAPPING"
              fi

              "$SCRIPT_DIR/pkg-build-pacman.sh" "$INTCOPY" "$PAC_DIR/" \
                --dep-map "$DEP_MAP" || \
                echo "WARNING: Failed to rebuild pacman pkg"
              rm -rf "$INTCOPY"
            done

            rm -rf "$TEMP_PAC"

            # Generate pacman database
            if ls "$PAC_DIR/"*.pkg.tar.zst 1>/dev/null 2>&1; then
              cd "$PAC_DIR"
              repo-add astralemu.db.tar.gz *.pkg.tar.zst
              cd ../../..
            fi
          done

      # ================================================================
      # LANDING PAGE
      # ================================================================
      - name: Generate landing page
        if: steps.check.outputs.has_pkgs == 'true'
        run: |
          pandoc README.md --from gfm --to html5 \
            --template pages/template.html \
            --metadata title="AstralEmu Packages" \
            -o gh-pages-dir/index.html

      # ================================================================
      # DEPLOY
      # ================================================================
      - name: Deploy to gh-pages
        if: steps.check.outputs.has_pkgs == 'true'
        run: |
          cd gh-pages-dir
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "Update package repositories" || echo "No changes"
          git push origin gh-pages

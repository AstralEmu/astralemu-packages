name: Update Package Repositories

on:
  workflow_call:
    inputs:
      artifact_pattern:
        type: string
        default: 'pkg-*'
        description: 'Pattern to download build artifacts'
      source_distro:
        type: string
        default: 'noble'
        description: 'Codename of the source distro the packages were built on'
      device:
        type: string
        required: true
        description: 'Device ID from devices.yml (e.g. l4t). Used for repo paths and dependency prefix'
      force_rebuild:
        type: boolean
        default: false
        description: 'Skip all existing-package checks — rebuild everything from scratch'
    secrets:
      GPG_PRIVATE_KEY:
        required: true

permissions:
  contents: write

jobs:
  # ==================================================================
  # NORMALIZE: Extract all packages to intermediate format (parallel)
  # ==================================================================
  normalize:
    runs-on: ubuntu-24.04
    outputs:
      arches: ${{ steps.normalize.outputs.arches }}
      count: ${{ steps.normalize.outputs.count }}
      matrix: ${{ steps.normalize.outputs.matrix }}
      seed_entry: ${{ steps.normalize.outputs.seed_entry }}
      matrix_rest: ${{ steps.normalize.outputs.matrix_rest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: ${{ inputs.artifact_pattern }}
          merge-multiple: true

      - name: Check for packages
        id: check
        run: |
          HAS_PKGS=false
          ls *.pkg.tar 1>/dev/null 2>&1 && HAS_PKGS=true
          ls *.deb 1>/dev/null 2>&1 && HAS_PKGS=true
          ls *.rpm 1>/dev/null 2>&1 && HAS_PKGS=true
          ls *.pkg.tar.zst 1>/dev/null 2>&1 && HAS_PKGS=true
          ls *.pkg.tar.xz 1>/dev/null 2>&1 && HAS_PKGS=true

          echo "has_pkgs=$HAS_PKGS" >> $GITHUB_OUTPUT
          if [[ "$HAS_PKGS" == "true" ]]; then
            echo "=== Downloaded packages ==="
            ls -la *.pkg.tar *.deb *.rpm *.pkg.tar.zst *.pkg.tar.xz 2>/dev/null || true
          else
            echo "No packages to publish"
          fi

      - name: Install tools
        if: steps.check.outputs.has_pkgs == 'true'
        run: sudo apt-get update && sudo apt-get install -y dpkg-dev rpm libarchive-tools zstd

      - name: Normalize all packages
        if: steps.check.outputs.has_pkgs == 'true'
        id: normalize
        run: |
          chmod +x scripts/pkg-extract.sh scripts/pkg-build-deb.sh scripts/pkg-build-rpm.sh scripts/pkg-build-pacman.sh scripts/resolve-deps.sh

          SOURCE_DISTRO="${{ inputs.source_distro }}"
          SCRIPT_DIR="$(pwd)/scripts"
          MAX_PARALLEL=12
          mkdir -p intermediates

          PKG_INDEX=0

          # 1) .pkg.tar = already intermediate, just extract (sequential — fast)
          for f in *.pkg.tar; do
            [[ -f "$f" ]] || continue
            INTDIR="intermediates/pkg-${PKG_INDEX}"
            mkdir -p "$INTDIR"
            tar xf "$f" -C "$INTDIR"
            echo "  [INT] $(cat "$INTDIR/meta/name") from $f"
            PKG_INDEX=$((PKG_INDEX + 1))
          done

          # 2) All other formats — parallel extraction
          for f in *.deb *.rpm *.pkg.tar.zst *.pkg.tar.xz; do
            [[ -f "$f" ]] || continue
            INTDIR="intermediates/pkg-${PKG_INDEX}"
            PKG_INDEX=$((PKG_INDEX + 1))
            "$SCRIPT_DIR/pkg-extract.sh" "$f" "$INTDIR" --source-distro "$SOURCE_DISTRO" &
            while [[ $(jobs -rp | wc -l) -ge $MAX_PARALLEL ]]; do wait -n; done
          done
          wait

          echo "=== Normalized $PKG_INDEX packages ==="

          # Validate intermediates — remove incomplete ones (e.g. OOM-killed extractions)
          for intdir in intermediates/pkg-*; do
            [[ -d "$intdir" ]] || continue
            if [[ ! -s "$intdir/meta/name" || ! -d "$intdir/root" ]]; then
              echo "WARNING: Removing incomplete intermediate: $intdir (name=$(cat "$intdir/meta/name" 2>/dev/null || echo '?'), root=$(test -d "$intdir/root" && echo ok || echo MISSING))"
              rm -rf "$intdir"
            fi
          done

          # Detect architectures
          ARCHES=""
          for intdir in intermediates/pkg-*; do
            [[ -s "$intdir/meta/name" && -d "$intdir/root" ]] || continue
            A=$(cat "$intdir/meta/arch")
            ARCHES="$ARCHES $A"
          done
          ARCHES=$(echo "$ARCHES" | tr ' ' '\n' | sort -u | grep -v '^$' | tr '\n' ' ')
          echo "arches=$ARCHES" >> $GITHUB_OUTPUT
          echo "Detected architectures: $ARCHES"
          echo "count=$PKG_INDEX" >> $GITHUB_OUTPUT

          # Generate own-packages skip list
          for intdir in intermediates/pkg-*; do
            [[ -s "$intdir/meta/name" && -d "$intdir/root" ]] || continue
            cat "$intdir/meta/name"
          done | sort -u > own-packages.txt
          echo "Own packages ($(wc -l < own-packages.txt) entries):"
          cat own-packages.txt

          # Fetch existing package filenames from gh-pages (only new path structure)
          if [[ "${{ inputs.force_rebuild }}" == "true" ]]; then
            echo "FORCE REBUILD: skipping existing-repo check — all packages will be rebuilt"
            touch existing-repo.txt
          else
            git fetch origin gh-pages 2>/dev/null || true
            git ls-tree -r --name-only origin/gh-pages 2>/dev/null \
              | grep -E '\.(deb|rpm|pkg\.tar\.zst)$' \
              | grep -E '/(device|deps)/' \
              > existing-repo.txt || touch existing-repo.txt
          fi
          echo "Existing repo: $(wc -l < existing-repo.txt) package files"

          # Generate matrix from distros.yml
          MATRIX="["
          for id in $(yq -r '.distros.apt[].id' distros.yml); do
            is_source=$([[ "$id" == "$SOURCE_DISTRO" ]] && echo true || echo false)
            MATRIX+="{\"distro\":\"$id\",\"format\":\"deb\",\"is_source\":$is_source},"
          done
          for id in $(yq -r '.distros.dnf[].id' distros.yml); do
            version=$(yq -r ".distros.dnf[] | select(.id == \"$id\") | .version" distros.yml)
            MATRIX+="{\"distro\":\"$id\",\"format\":\"rpm\",\"is_source\":false,\"version\":\"$version\"},"
          done
          for id in $(yq -r '.distros.pacman[].id' distros.yml); do
            MATRIX+="{\"distro\":\"$id\",\"format\":\"pacman\",\"is_source\":false},"
          done
          MATRIX="${MATRIX%,}]"
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Matrix: $MATRIX"

          # Detect source format from distros.yml, then pick most distant target as seed
          SOURCE_FORMAT=""
          for fmt in apt dnf pacman; do
            if yq -e ".distros.${fmt}[] | select(.id == \"$SOURCE_DISTRO\")" distros.yml > /dev/null 2>&1; then
              case "$fmt" in
                apt) SOURCE_FORMAT="deb" ;;
                dnf) SOURCE_FORMAT="rpm" ;;
                pacman) SOURCE_FORMAT="pacman" ;;
              esac
              break
            fi
          done
          SOURCE_FORMAT="${SOURCE_FORMAT:-deb}"
          case "$SOURCE_FORMAT" in
            deb|rpm) SEED_FORMAT="pacman" ;;
            pacman)  SEED_FORMAT="deb" ;;
          esac
          SEED_ENTRY=$(echo "$MATRIX" | jq -c "[.[] | select(.format == \"$SEED_FORMAT\")][0]")
          MATRIX_REST=$(echo "$MATRIX" | jq -c "[.[] | select(. != $SEED_ENTRY)]")
          echo "seed_entry=$SEED_ENTRY" >> $GITHUB_OUTPUT
          echo "matrix_rest=$MATRIX_REST" >> $GITHUB_OUTPUT
          echo "Seed: $SEED_ENTRY"

      - name: Upload intermediates
        if: steps.check.outputs.has_pkgs == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: intermediates-${{ inputs.device }}
          path: |
            intermediates/
            own-packages.txt
            existing-repo.txt
            scripts/
            distros.yml
            pages/
            README.md
          retention-days: 1

  # ==================================================================
  # BUILD-REPO-SEED: Single distro (most distant from source) to fill dep cache
  # ==================================================================
  build-repo-seed:
    needs: normalize
    if: needs.normalize.outputs.count > 0
    runs-on: ubuntu-24.04
    steps:
      - name: Download intermediates
        uses: actions/download-artifact@v4
        with:
          name: intermediates-${{ inputs.device }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64,arm

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev apt-utils rpm createrepo-c libarchive-tools zstd
          chmod +x scripts/pkg-extract.sh scripts/pkg-build-deb.sh scripts/pkg-build-rpm.sh scripts/pkg-build-pacman.sh scripts/resolve-deps.sh

      - name: Build ${{ fromJson(needs.normalize.outputs.seed_entry).format }} repo for ${{ fromJson(needs.normalize.outputs.seed_entry).distro }} (seed)
        run: |
          SCRIPT_DIR="$(pwd)/scripts"
          DEP_MAP="$SCRIPT_DIR/dep-map.conf"
          SOURCE_DISTRO="${{ inputs.source_distro }}"
          DEVICE="${{ inputs.device }}"
          DISTRO="${{ fromJson(needs.normalize.outputs.seed_entry).distro }}"
          FORMAT="${{ fromJson(needs.normalize.outputs.seed_entry).format }}"
          IS_SOURCE="${{ fromJson(needs.normalize.outputs.seed_entry).is_source }}"
          MAX_PARALLEL=8

          echo "=== Building $FORMAT repo for $DISTRO ==="
          FAIL_LOG="build-failures.log"
          > "$FAIL_LOG"

          # Determine build script
          case "$FORMAT" in
            deb)    BUILD_SCRIPT="$SCRIPT_DIR/pkg-build-deb.sh" ;;
            rpm)    BUILD_SCRIPT="$SCRIPT_DIR/pkg-build-rpm.sh" ;;
            pacman) BUILD_SCRIPT="$SCRIPT_DIR/pkg-build-pacman.sh" ;;
          esac

          # Map arch for directory names
          map_dir_arch() {
            local arch="$1"
            case "$FORMAT" in
              deb)
                case "$arch" in
                  aarch64) echo "arm64" ;;
                  x86_64)  echo "amd64" ;;
                  armhf)   echo "armhf" ;;
                  *)       echo "$arch" ;;
                esac ;;
              rpm)
                case "$arch" in
                  aarch64) echo "aarch64" ;;
                  x86_64)  echo "x86_64" ;;
                  armhf)   echo "armv7hl" ;;
                  all)     echo "noarch" ;;
                  *)       echo "$arch" ;;
                esac ;;
              pacman)
                case "$arch" in
                  aarch64) echo "aarch64" ;;
                  x86_64)  echo "x86_64" ;;
                  armhf)   echo "armv7h" ;;
                  all)     echo "any" ;;
                  *)       echo "$arch" ;;
                esac ;;
            esac
          }

          # Check if a package (name+version+arch) already exists in the repo
          pkg_exists_in_repo() {
            local name="$1" version="$2" format="$3" arch="$4"
            local expected
            case "$format" in
              deb)
                local deb_arch
                case "$arch" in aarch64) deb_arch="arm64";; x86_64) deb_arch="amd64";; *) deb_arch="$arch";; esac
                expected="${name}_$(echo "$version" | sed 's/^[0-9]*://')_${deb_arch}.deb"
                ;;
              rpm)
                local rpm_arch
                case "$arch" in aarch64) rpm_arch="aarch64";; x86_64) rpm_arch="x86_64";; armhf) rpm_arch="armv7hl";; all) rpm_arch="noarch";; *) rpm_arch="$arch";; esac
                expected="${name}-$(echo "$version" | sed 's/+[^-]*//' | tr ':~' '..' | sed 's/-/./g')-1.${rpm_arch}.rpm"
                ;;
              pacman)
                local pac_arch
                case "$arch" in aarch64) pac_arch="aarch64";; x86_64) pac_arch="x86_64";; armhf) pac_arch="armv7h";; all) pac_arch="any";; *) pac_arch="$arch";; esac
                expected="${name}-$(echo "$version" | sed 's/+[^-]*//; s/^[0-9]*://; s/-/./g')-1-${pac_arch}.pkg.tar.zst"
                ;;
            esac
            grep -qF "/$expected" existing-repo.txt 2>/dev/null
          }

          # Create output structure
          mkdir -p repo-output

          for arch in ${{ needs.normalize.outputs.arches }}; do
            DIR_ARCH=$(map_dir_arch "$arch")
            echo ""
            echo "--- $DISTRO / $DIR_ARCH ($arch) ---"

            # Create format-specific output dirs
            # Device packages → device/{id}, deps → deps/{source_distro}
            case "$FORMAT" in
              deb)
                POOL_DIR="repo-output/apt/device/${DEVICE}/pool/${DISTRO}"
                DEP_POOL_DIR="repo-output/apt/deps/${SOURCE_DISTRO}/pool/${DISTRO}"
                mkdir -p "$POOL_DIR" "$DEP_POOL_DIR"
                OUTPUT_DIR="$POOL_DIR"
                DEP_OUTPUT_DIR="$DEP_POOL_DIR"
                ;;
              rpm)
                VERSION="${{ fromJson(needs.normalize.outputs.seed_entry).version }}"
                OUTPUT_DIR="repo-output/dnf/device/${DEVICE}/${VERSION}/${DIR_ARCH}"
                DEP_OUTPUT_DIR="repo-output/dnf/deps/${SOURCE_DISTRO}/${VERSION}/${DIR_ARCH}"
                mkdir -p "$OUTPUT_DIR" "$DEP_OUTPUT_DIR"
                ;;
              pacman)
                OUTPUT_DIR="repo-output/pacman/device/${DEVICE}/${DIR_ARCH}"
                DEP_OUTPUT_DIR="repo-output/pacman/deps/${SOURCE_DISTRO}/${DIR_ARCH}"
                mkdir -p "$OUTPUT_DIR" "$DEP_OUTPUT_DIR"
                ;;
            esac

            if [[ "$IS_SOURCE" == "true" ]]; then
              # Source distro: build directly, no dep resolution
              echo "Building packages (source distro, no dep resolution)..."
              for intdir in intermediates/pkg-*; do
                [[ -s "$intdir/meta/name" && -d "$intdir/root" ]] || continue
                [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
                PKG_NAME=$(cat "$intdir/meta/name")
                PKG_VERSION=$(cat "$intdir/meta/version")
                if pkg_exists_in_repo "$PKG_NAME" "$PKG_VERSION" "$FORMAT" "$arch"; then
                  echo "SKIP: $PKG_NAME ($PKG_VERSION) already in $DISTRO repo"
                  continue
                fi
                (
                  INTCOPY=$(mktemp -d)
                  cp -a "$intdir"/* "$INTCOPY/"
                  TMPOUT=$(mktemp -d)
                  if "$BUILD_SCRIPT" "$INTCOPY" "$TMPOUT/" --dep-map "$DEP_MAP" 2>&1; then
                    cp "$TMPOUT"/* "$OUTPUT_DIR/" 2>/dev/null || true
                  else
                    echo "FAIL: $(cat "$INTCOPY/meta/name" 2>/dev/null) — build for $DISTRO" | tee -a "$FAIL_LOG"
                  fi
                  rm -rf "$INTCOPY" "$TMPOUT"
                ) &
                while [[ $(jobs -rp | wc -l) -ge $MAX_PARALLEL ]]; do wait -n; done
              done
              wait
            else
              # Non-source distro: build temp → resolve deps → rebuild with mapping

              # Step 1: Build temp packages for dep scanning (parallel)
              echo "Step 1: Building temp packages for dep scanning..."
              TEMP_DIR=$(mktemp -d)
              for intdir in intermediates/pkg-*; do
                [[ -s "$intdir/meta/name" && -d "$intdir/root" ]] || continue
                [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
                (
                  INTCOPY=$(mktemp -d)
                  cp -a "$intdir"/* "$INTCOPY/"
                  TMPOUT=$(mktemp -d)
                  if "$BUILD_SCRIPT" "$INTCOPY" "$TMPOUT/" --dep-map "$DEP_MAP" 2>"$TMPOUT/build.err"; then
                    cp "$TMPOUT"/* "$TEMP_DIR/" 2>/dev/null || true
                  else
                    { echo "FAIL: $(cat "$INTCOPY/meta/name" 2>/dev/null) — temp build for $DISTRO"; grep -i 'error:' "$TMPOUT/build.err" 2>/dev/null | tail -5 | sed 's/^/  /'; } >> "$FAIL_LOG"
                  fi
                  rm -rf "$INTCOPY" "$TMPOUT"
                ) &
                while [[ $(jobs -rp | wc -l) -ge $MAX_PARALLEL ]]; do wait -n; done
              done
              wait

              # Step 2: Resolve deps (batch fetch + parallel rebuild)
              echo "Step 2: Resolving dependencies..."
              FETCH_DIR="fetched-deps-${DISTRO}-${arch}"
              mkdir -p "$FETCH_DIR"
              "$SCRIPT_DIR/resolve-deps.sh" \
                --source-pkgs "$TEMP_DIR" \
                --source-distro "$SOURCE_DISTRO" \
                --target-distro "$DISTRO" \
                --target-format "$FORMAT" \
                --distros-config distros.yml \
                --dep-map "$DEP_MAP" \
                --ignore-file "$SCRIPT_DIR/dep-ignore.conf" \
                --output-dir "$FETCH_DIR" \
                --arch "$arch" \
                --skip-names own-packages.txt \
                --existing-repo existing-repo.txt \
                --prefix "$SOURCE_DISTRO" \
                --cache-dir dep-cache/ || echo "FAIL: dependency resolution for $DISTRO/$arch" | tee -a "$FAIL_LOG"

              # Step 3: Copy prefixed dep packages to shared deps output
              case "$FORMAT" in
                deb)    for f in "$FETCH_DIR"/*.deb;         do [[ -f "$f" ]] && cp "$f" "$DEP_OUTPUT_DIR/"; done ;;
                rpm)    for f in "$FETCH_DIR"/*.rpm;         do [[ -f "$f" ]] && cp "$f" "$DEP_OUTPUT_DIR/"; done ;;
                pacman) for f in "$FETCH_DIR"/*.pkg.tar.zst; do [[ -f "$f" ]] && cp "$f" "$DEP_OUTPUT_DIR/"; done ;;
              esac

              # Step 4: Rebuild our packages with mapping applied (parallel)
              echo "Step 4: Rebuilding packages with dependency mapping..."
              MAPPING="$FETCH_DIR/dep-mapping.txt"
              for intdir in intermediates/pkg-*; do
                [[ -s "$intdir/meta/name" && -d "$intdir/root" ]] || continue
                [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
                PKG_NAME=$(cat "$intdir/meta/name")
                PKG_VERSION=$(cat "$intdir/meta/version")
                if pkg_exists_in_repo "$PKG_NAME" "$PKG_VERSION" "$FORMAT" "$arch"; then
                  echo "SKIP: $PKG_NAME ($PKG_VERSION) already in $DISTRO repo"
                  continue
                fi
                (
                  INTCOPY=$(mktemp -d)
                  cp -a "$intdir"/* "$INTCOPY/"

                  if [[ -s "$MAPPING" ]]; then
                    while IFS='=' read -r orig prefixed; do
                      [[ -z "$orig" ]] && continue
                      sed -i "s/^${orig}$/${prefixed}/" "$INTCOPY/meta/depends" 2>/dev/null || true
                    done < "$MAPPING"
                  fi

                  TMPOUT=$(mktemp -d)
                  if "$BUILD_SCRIPT" "$INTCOPY" "$TMPOUT/" --dep-map "$DEP_MAP" 2>"$TMPOUT/build.err"; then
                    cp "$TMPOUT"/* "$OUTPUT_DIR/" 2>/dev/null || true
                  else
                    { echo "FAIL: $(cat "$INTCOPY/meta/name" 2>/dev/null) — rebuild for $DISTRO"; grep -i 'error:' "$TMPOUT/build.err" 2>/dev/null | tail -5 | sed 's/^/  /'; } >> "$FAIL_LOG"
                  fi
                  rm -rf "$INTCOPY" "$TMPOUT"
                ) &
                while [[ $(jobs -rp | wc -l) -ge $MAX_PARALLEL ]]; do wait -n; done
              done
              wait

              rm -rf "$TEMP_DIR"
            fi
          done

          if [[ -s "$FAIL_LOG" ]]; then
            echo ""
            echo "========================================="
            echo "FAILURES ($DISTRO / $FORMAT):"
            cat "$FAIL_LOG"
            echo "========================================="
          fi
          echo "=== Done building $FORMAT repo for $DISTRO ==="

      - name: Upload repo artifact
        uses: actions/upload-artifact@v4
        with:
          name: repo-${{ inputs.device }}-${{ fromJson(needs.normalize.outputs.seed_entry).distro }}
          path: repo-output/
          retention-days: 1

      - name: Upload dep cache
        uses: actions/upload-artifact@v4
        with:
          name: dep-cache-${{ inputs.device }}
          path: dep-cache/
          retention-days: 1

  # ==================================================================
  # BUILD-REPO: Remaining distros (matrix, reuses dep cache from seed)
  # ==================================================================
  build-repo:
    needs: [normalize, build-repo-seed]
    if: needs.normalize.outputs.count > 0 && fromJson(needs.normalize.outputs.matrix_rest)[0] != null
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.normalize.outputs.matrix_rest) }}
    steps:
      - name: Download intermediates
        uses: actions/download-artifact@v4
        with:
          name: intermediates-${{ inputs.device }}

      - name: Download dep cache
        uses: actions/download-artifact@v4
        with:
          name: dep-cache-${{ inputs.device }}
          path: dep-cache/
        continue-on-error: true

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64,arm

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y dpkg-dev apt-utils rpm createrepo-c libarchive-tools zstd
          chmod +x scripts/pkg-extract.sh scripts/pkg-build-deb.sh scripts/pkg-build-rpm.sh scripts/pkg-build-pacman.sh scripts/resolve-deps.sh

      - name: Build ${{ matrix.format }} repo for ${{ matrix.distro }}
        run: |
          SCRIPT_DIR="$(pwd)/scripts"
          DEP_MAP="$SCRIPT_DIR/dep-map.conf"
          SOURCE_DISTRO="${{ inputs.source_distro }}"
          DEVICE="${{ inputs.device }}"
          DISTRO="${{ matrix.distro }}"
          FORMAT="${{ matrix.format }}"
          IS_SOURCE="${{ matrix.is_source }}"
          MAX_PARALLEL=8

          echo "=== Building $FORMAT repo for $DISTRO ==="
          FAIL_LOG="build-failures.log"
          > "$FAIL_LOG"

          # Determine build script
          case "$FORMAT" in
            deb)    BUILD_SCRIPT="$SCRIPT_DIR/pkg-build-deb.sh" ;;
            rpm)    BUILD_SCRIPT="$SCRIPT_DIR/pkg-build-rpm.sh" ;;
            pacman) BUILD_SCRIPT="$SCRIPT_DIR/pkg-build-pacman.sh" ;;
          esac

          # Map arch for directory names
          map_dir_arch() {
            local arch="$1"
            case "$FORMAT" in
              deb)
                case "$arch" in
                  aarch64) echo "arm64" ;;
                  x86_64)  echo "amd64" ;;
                  armhf)   echo "armhf" ;;
                  *)       echo "$arch" ;;
                esac ;;
              rpm)
                case "$arch" in
                  aarch64) echo "aarch64" ;;
                  x86_64)  echo "x86_64" ;;
                  armhf)   echo "armv7hl" ;;
                  all)     echo "noarch" ;;
                  *)       echo "$arch" ;;
                esac ;;
              pacman)
                case "$arch" in
                  aarch64) echo "aarch64" ;;
                  x86_64)  echo "x86_64" ;;
                  armhf)   echo "armv7h" ;;
                  all)     echo "any" ;;
                  *)       echo "$arch" ;;
                esac ;;
            esac
          }

          # Check if a package (name+version+arch) already exists in the repo
          pkg_exists_in_repo() {
            local name="$1" version="$2" format="$3" arch="$4"
            local expected
            case "$format" in
              deb)
                local deb_arch
                case "$arch" in aarch64) deb_arch="arm64";; x86_64) deb_arch="amd64";; *) deb_arch="$arch";; esac
                expected="${name}_$(echo "$version" | sed 's/^[0-9]*://')_${deb_arch}.deb"
                ;;
              rpm)
                local rpm_arch
                case "$arch" in aarch64) rpm_arch="aarch64";; x86_64) rpm_arch="x86_64";; armhf) rpm_arch="armv7hl";; all) rpm_arch="noarch";; *) rpm_arch="$arch";; esac
                expected="${name}-$(echo "$version" | sed 's/+[^-]*//' | tr ':~' '..' | sed 's/-/./g')-1.${rpm_arch}.rpm"
                ;;
              pacman)
                local pac_arch
                case "$arch" in aarch64) pac_arch="aarch64";; x86_64) pac_arch="x86_64";; armhf) pac_arch="armv7h";; all) pac_arch="any";; *) pac_arch="$arch";; esac
                expected="${name}-$(echo "$version" | sed 's/+[^-]*//; s/^[0-9]*://; s/-/./g')-1-${pac_arch}.pkg.tar.zst"
                ;;
            esac
            grep -qF "/$expected" existing-repo.txt 2>/dev/null
          }

          # Create output structure
          mkdir -p repo-output

          for arch in ${{ needs.normalize.outputs.arches }}; do
            DIR_ARCH=$(map_dir_arch "$arch")
            echo ""
            echo "--- $DISTRO / $DIR_ARCH ($arch) ---"

            # Create format-specific output dirs
            # Device packages → device/{id}, deps → deps/{source_distro}
            case "$FORMAT" in
              deb)
                POOL_DIR="repo-output/apt/device/${DEVICE}/pool/${DISTRO}"
                DEP_POOL_DIR="repo-output/apt/deps/${SOURCE_DISTRO}/pool/${DISTRO}"
                mkdir -p "$POOL_DIR" "$DEP_POOL_DIR"
                OUTPUT_DIR="$POOL_DIR"
                DEP_OUTPUT_DIR="$DEP_POOL_DIR"
                ;;
              rpm)
                VERSION="${{ matrix.version }}"
                OUTPUT_DIR="repo-output/dnf/device/${DEVICE}/${VERSION}/${DIR_ARCH}"
                DEP_OUTPUT_DIR="repo-output/dnf/deps/${SOURCE_DISTRO}/${VERSION}/${DIR_ARCH}"
                mkdir -p "$OUTPUT_DIR" "$DEP_OUTPUT_DIR"
                ;;
              pacman)
                OUTPUT_DIR="repo-output/pacman/device/${DEVICE}/${DIR_ARCH}"
                DEP_OUTPUT_DIR="repo-output/pacman/deps/${SOURCE_DISTRO}/${DIR_ARCH}"
                mkdir -p "$OUTPUT_DIR" "$DEP_OUTPUT_DIR"
                ;;
            esac

            if [[ "$IS_SOURCE" == "true" ]]; then
              # Source distro: build directly, no dep resolution
              echo "Building packages (source distro, no dep resolution)..."
              for intdir in intermediates/pkg-*; do
                [[ -s "$intdir/meta/name" && -d "$intdir/root" ]] || continue
                [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
                PKG_NAME=$(cat "$intdir/meta/name")
                PKG_VERSION=$(cat "$intdir/meta/version")
                if pkg_exists_in_repo "$PKG_NAME" "$PKG_VERSION" "$FORMAT" "$arch"; then
                  echo "SKIP: $PKG_NAME ($PKG_VERSION) already in $DISTRO repo"
                  continue
                fi
                (
                  INTCOPY=$(mktemp -d)
                  cp -a "$intdir"/* "$INTCOPY/"
                  TMPOUT=$(mktemp -d)
                  if "$BUILD_SCRIPT" "$INTCOPY" "$TMPOUT/" --dep-map "$DEP_MAP" 2>&1; then
                    cp "$TMPOUT"/* "$OUTPUT_DIR/" 2>/dev/null || true
                  else
                    echo "FAIL: $(cat "$INTCOPY/meta/name" 2>/dev/null) — build for $DISTRO" | tee -a "$FAIL_LOG"
                  fi
                  rm -rf "$INTCOPY" "$TMPOUT"
                ) &
                while [[ $(jobs -rp | wc -l) -ge $MAX_PARALLEL ]]; do wait -n; done
              done
              wait
            else
              # Non-source distro: build temp → resolve deps → rebuild with mapping

              # Step 1: Build temp packages for dep scanning (parallel)
              echo "Step 1: Building temp packages for dep scanning..."
              TEMP_DIR=$(mktemp -d)
              for intdir in intermediates/pkg-*; do
                [[ -s "$intdir/meta/name" && -d "$intdir/root" ]] || continue
                [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
                (
                  INTCOPY=$(mktemp -d)
                  cp -a "$intdir"/* "$INTCOPY/"
                  TMPOUT=$(mktemp -d)
                  if "$BUILD_SCRIPT" "$INTCOPY" "$TMPOUT/" --dep-map "$DEP_MAP" 2>"$TMPOUT/build.err"; then
                    cp "$TMPOUT"/* "$TEMP_DIR/" 2>/dev/null || true
                  else
                    { echo "FAIL: $(cat "$INTCOPY/meta/name" 2>/dev/null) — temp build for $DISTRO"; grep -i 'error:' "$TMPOUT/build.err" 2>/dev/null | tail -5 | sed 's/^/  /'; } >> "$FAIL_LOG"
                  fi
                  rm -rf "$INTCOPY" "$TMPOUT"
                ) &
                while [[ $(jobs -rp | wc -l) -ge $MAX_PARALLEL ]]; do wait -n; done
              done
              wait

              # Step 2: Resolve deps (batch fetch + parallel rebuild)
              echo "Step 2: Resolving dependencies..."
              FETCH_DIR="fetched-deps-${DISTRO}-${arch}"
              mkdir -p "$FETCH_DIR"
              "$SCRIPT_DIR/resolve-deps.sh" \
                --source-pkgs "$TEMP_DIR" \
                --source-distro "$SOURCE_DISTRO" \
                --target-distro "$DISTRO" \
                --target-format "$FORMAT" \
                --distros-config distros.yml \
                --dep-map "$DEP_MAP" \
                --ignore-file "$SCRIPT_DIR/dep-ignore.conf" \
                --output-dir "$FETCH_DIR" \
                --arch "$arch" \
                --skip-names own-packages.txt \
                --existing-repo existing-repo.txt \
                --prefix "$SOURCE_DISTRO" \
                --cache-dir dep-cache/ || echo "FAIL: dependency resolution for $DISTRO/$arch" | tee -a "$FAIL_LOG"

              # Step 3: Copy prefixed dep packages to shared deps output
              case "$FORMAT" in
                deb)    for f in "$FETCH_DIR"/*.deb;         do [[ -f "$f" ]] && cp "$f" "$DEP_OUTPUT_DIR/"; done ;;
                rpm)    for f in "$FETCH_DIR"/*.rpm;         do [[ -f "$f" ]] && cp "$f" "$DEP_OUTPUT_DIR/"; done ;;
                pacman) for f in "$FETCH_DIR"/*.pkg.tar.zst; do [[ -f "$f" ]] && cp "$f" "$DEP_OUTPUT_DIR/"; done ;;
              esac

              # Step 4: Rebuild our packages with mapping applied (parallel)
              echo "Step 4: Rebuilding packages with dependency mapping..."
              MAPPING="$FETCH_DIR/dep-mapping.txt"
              for intdir in intermediates/pkg-*; do
                [[ -s "$intdir/meta/name" && -d "$intdir/root" ]] || continue
                [[ "$(cat "$intdir/meta/arch")" == "$arch" ]] || continue
                PKG_NAME=$(cat "$intdir/meta/name")
                PKG_VERSION=$(cat "$intdir/meta/version")
                if pkg_exists_in_repo "$PKG_NAME" "$PKG_VERSION" "$FORMAT" "$arch"; then
                  echo "SKIP: $PKG_NAME ($PKG_VERSION) already in $DISTRO repo"
                  continue
                fi
                (
                  INTCOPY=$(mktemp -d)
                  cp -a "$intdir"/* "$INTCOPY/"

                  if [[ -s "$MAPPING" ]]; then
                    while IFS='=' read -r orig prefixed; do
                      [[ -z "$orig" ]] && continue
                      sed -i "s/^${orig}$/${prefixed}/" "$INTCOPY/meta/depends" 2>/dev/null || true
                    done < "$MAPPING"
                  fi

                  TMPOUT=$(mktemp -d)
                  if "$BUILD_SCRIPT" "$INTCOPY" "$TMPOUT/" --dep-map "$DEP_MAP" 2>"$TMPOUT/build.err"; then
                    cp "$TMPOUT"/* "$OUTPUT_DIR/" 2>/dev/null || true
                  else
                    { echo "FAIL: $(cat "$INTCOPY/meta/name" 2>/dev/null) — rebuild for $DISTRO"; grep -i 'error:' "$TMPOUT/build.err" 2>/dev/null | tail -5 | sed 's/^/  /'; } >> "$FAIL_LOG"
                  fi
                  rm -rf "$INTCOPY" "$TMPOUT"
                ) &
                while [[ $(jobs -rp | wc -l) -ge $MAX_PARALLEL ]]; do wait -n; done
              done
              wait

              rm -rf "$TEMP_DIR"
            fi
          done

          if [[ -s "$FAIL_LOG" ]]; then
            echo ""
            echo "========================================="
            echo "FAILURES ($DISTRO / $FORMAT):"
            cat "$FAIL_LOG"
            echo "========================================="
          fi
          echo "=== Done building $FORMAT repo for $DISTRO ==="

      - name: Upload repo artifact
        uses: actions/upload-artifact@v4
        with:
          name: repo-${{ inputs.device }}-${{ matrix.distro }}
          path: repo-output/
          retention-days: 1

  # ==================================================================
  # DEPLOY: Merge all repo artifacts and push to gh-pages
  # ==================================================================
  deploy:
    needs: [normalize, build-repo-seed, build-repo]
    if: always() && needs.normalize.outputs.count > 0
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Download intermediates (for pages template)
        uses: actions/download-artifact@v4
        with:
          name: intermediates-${{ inputs.device }}
          path: intermediates-data/

      - name: Download all repo artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: repo-${{ inputs.device }}-*
          path: repo-artifacts/

      - name: Install tools
        run: sudo apt-get update && sudo apt-get install -y pandoc apt-utils dpkg-dev createrepo-c

      - name: Import GPG key
        run: echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

      - name: Checkout gh-pages
        run: |
          git fetch --depth=1 origin gh-pages:gh-pages || true
          git worktree add gh-pages-dir gh-pages || {
            git worktree add --detach gh-pages-dir
            cd gh-pages-dir
            git checkout --orphan gh-pages
            git rm -rf . 2>/dev/null || true
            cd ..
          }
          DEVICE="${{ inputs.device }}"
          SOURCE_DISTRO="${{ inputs.source_distro }}"
          # Force rebuild: wipe gh-pages content for this device to start clean
          if [[ "${{ inputs.force_rebuild }}" == "true" ]]; then
            echo "FORCE REBUILD: wiping existing gh-pages content for device ${DEVICE}"
            for fmt in apt dnf pacman; do
              rm -rf "gh-pages-dir/${fmt}/device/${DEVICE}"
              rm -rf "gh-pages-dir/${fmt}/${DEVICE}"
            done
            # Also wipe deps for this source_distro (will be rebuilt)
            for fmt in apt dnf pacman; do
              rm -rf "gh-pages-dir/${fmt}/deps/${SOURCE_DISTRO}"
            done
          fi
          # Device repos
          mkdir -p "gh-pages-dir/apt/device/${DEVICE}" "gh-pages-dir/dnf/device/${DEVICE}" "gh-pages-dir/pacman/device/${DEVICE}"
          # Shared deps repos
          mkdir -p "gh-pages-dir/apt/deps/${SOURCE_DISTRO}" "gh-pages-dir/dnf/deps/${SOURCE_DISTRO}" "gh-pages-dir/pacman/deps/${SOURCE_DISTRO}"
          # Migration: copy ALL package files from old flat paths to new device/ subdirs
          # Uses cp -n (no-clobber) so existing files in new paths are not overwritten
          for fmt in apt dnf pacman; do
            if [[ -d "gh-pages-dir/${fmt}/${DEVICE}" ]]; then
              echo "Migrating gh-pages-dir/${fmt}/${DEVICE}/ → gh-pages-dir/${fmt}/device/${DEVICE}/"
              cp -a --no-clobber "gh-pages-dir/${fmt}/${DEVICE}"/* "gh-pages-dir/${fmt}/device/${DEVICE}/" 2>/dev/null || true
              echo "Removing old path: ${fmt}/${DEVICE}/"
              rm -rf "gh-pages-dir/${fmt}/${DEVICE}"
            fi
          done
          # Clean up non-standard pacman arm64 dir (should be aarch64)
          if [[ -d "gh-pages-dir/pacman/device/${DEVICE}/arm64" ]]; then
            echo "Removing non-standard arch dir: pacman/device/${DEVICE}/arm64/"
            rm -rf "gh-pages-dir/pacman/device/${DEVICE}/arm64"
          fi

      - name: Merge repo artifacts
        run: |
          for repo_dir in repo-artifacts/repo-*/; do
            [[ -d "$repo_dir" ]] || continue
            echo "Merging: $repo_dir"
            cp -a "$repo_dir"/* gh-pages-dir/ 2>/dev/null || true
          done
          echo "=== Merged structure ==="
          find gh-pages-dir -type f | head -50

      - name: Cleanup old package versions
        run: |
          DEVICE="${{ inputs.device }}"

          # Keep only 3 latest major versions per package, delete older ones
          cleanup_old_versions() {
            local dir="$1" format="$2"
            [[ -d "$dir" ]] || return 0

            declare -A SEEN_MAJORS
            declare -A DELETE_FILES

            for file in "$dir"/*; do
              [[ -f "$file" ]] || continue
              local bn
              bn=$(basename "$file")
              local pkg_name="" version=""

              case "$format" in
                deb)
                  pkg_name="${bn%%_*}"
                  version=$(echo "$bn" | cut -d_ -f2)
                  ;;
                rpm)
                  local stem="${bn%.*.rpm}"
                  pkg_name=$(echo "$stem" | rev | cut -d- -f3- | rev)
                  version=$(echo "$stem" | rev | cut -d- -f2 | rev)
                  ;;
                pacman)
                  local stem="${bn%.pkg.tar.zst}"
                  pkg_name=$(echo "$stem" | rev | cut -d- -f3- | rev)
                  version=$(echo "$stem" | rev | cut -d- -f2 | rev)
                  ;;
              esac

              local major
              major=$(echo "$version" | cut -d. -f1)
              [[ "$major" =~ ^[0-9]+$ ]] || continue

              SEEN_MAJORS["$pkg_name"]+=" $major"
              DELETE_FILES["${pkg_name}:${major}"]+=" $file"
            done

            for pkg_name in $(printf '%s\n' "${!SEEN_MAJORS[@]}" | sort -u); do
              local majors
              majors=$(echo "${SEEN_MAJORS[$pkg_name]}" | tr ' ' '\n' | sort -rn | uniq)
              local count=0
              for major in $majors; do
                count=$((count + 1))
                if [ $count -gt 3 ]; then
                  for f in ${DELETE_FILES["${pkg_name}:${major}"]}; do
                    echo "  CLEANUP: $(basename "$f") (major=$major, keeping latest 3)"
                    rm -f "$f"
                  done
                fi
              done
            done
          }

          echo "=== Cleaning old package versions ==="
          SOURCE_DISTRO="${{ inputs.source_distro }}"
          # Device repos
          for pool_dir in gh-pages-dir/apt/device/${DEVICE}/pool/*/; do
            cleanup_old_versions "$pool_dir" "deb"
          done
          for rpm_dir in gh-pages-dir/dnf/device/${DEVICE}/*/*/; do
            cleanup_old_versions "$rpm_dir" "rpm"
          done
          for pac_dir in gh-pages-dir/pacman/device/${DEVICE}/*/; do
            cleanup_old_versions "$pac_dir" "pacman"
          done
          # Deps repos
          for pool_dir in gh-pages-dir/apt/deps/${SOURCE_DISTRO}/pool/*/; do
            cleanup_old_versions "$pool_dir" "deb"
          done
          for rpm_dir in gh-pages-dir/dnf/deps/${SOURCE_DISTRO}/*/*/; do
            cleanup_old_versions "$rpm_dir" "rpm"
          done
          for pac_dir in gh-pages-dir/pacman/deps/${SOURCE_DISTRO}/*/; do
            cleanup_old_versions "$pac_dir" "pacman"
          done

      - name: Remove oversized files
        run: |
          MAX_MB=95
          find gh-pages-dir -type f -size +${MAX_MB}M | while read -r f; do
            echo "Removing oversized file: $f ($(du -h "$f" | cut -f1))"
            rm -f "$f"
          done

      - name: Generate repo metadata
        run: |
          DEVICE="${{ inputs.device }}"
          SOURCE_DISTRO="${{ inputs.source_distro }}"

          echo "=== Generating APT metadata ==="
          APT_DISTROS=$(yq -r '.distros.apt[].id' distros.yml)
          for repo_base in "gh-pages-dir/apt/device/${DEVICE}" "gh-pages-dir/apt/deps/${SOURCE_DISTRO}"; do
            [[ -d "$repo_base" ]] || continue
            for distro in $APT_DISTROS; do
              [[ -d "$repo_base/pool/$distro" ]] || continue
              # Extract unique architectures from deb filenames
              POOL_ARCHES=$(ls "$repo_base/pool/$distro/"*.deb 2>/dev/null | sed 's/.*_\([^_]*\)\.deb$/\1/' | sort -u)
              [[ -z "$POOL_ARCHES" ]] && continue
              for deb_arch in $POOL_ARCHES; do
                mkdir -p "$repo_base/dists/$distro/main/binary-$deb_arch"
                (cd "$repo_base" && dpkg-scanpackages --arch "$deb_arch" "pool/$distro" > "dists/$distro/main/binary-$deb_arch/Packages" 2>/dev/null || true)
                gzip -k -f "$repo_base/dists/$distro/main/binary-$deb_arch/Packages"
                echo "  $(basename "$repo_base") $distro/$deb_arch: $(grep -c '^Package:' "$repo_base/dists/$distro/main/binary-$deb_arch/Packages" 2>/dev/null || echo 0) packages"
              done
            done
          done

          echo "=== Generating RPM metadata ==="
          for rpm_root in "gh-pages-dir/dnf/device/${DEVICE}" "gh-pages-dir/dnf/deps/${SOURCE_DISTRO}"; do
            [[ -d "$rpm_root" ]] || continue
            find "$rpm_root" -name '*.rpm' -printf '%h\n' 2>/dev/null | sort -u | while read -r rpm_dir; do
              echo "  createrepo_c $rpm_dir"
              createrepo_c "$rpm_dir/"
            done
          done

          echo "=== Generating Pacman metadata ==="
          for pac_root in "gh-pages-dir/pacman/device/${DEVICE}" "gh-pages-dir/pacman/deps/${SOURCE_DISTRO}"; do
            [[ -d "$pac_root" ]] || continue
            for pac_dir in "$pac_root"/*/; do
              [[ -d "$pac_dir" ]] || continue
              ls "$pac_dir"/*.pkg.tar.zst 1>/dev/null 2>&1 || continue
              db_name="astralemu"
              echo "$pac_dir" | grep -q "/deps/" && db_name="astralemu-deps"
              rm -f "$pac_dir"/${db_name}.db* "$pac_dir"/${db_name}.files*
              echo "  repo-add $pac_dir${db_name}.db.tar.gz"
              docker run --rm -v "$(realpath "$pac_dir"):/repo" archlinux:latest \
                bash -c "cd /repo && repo-add ${db_name}.db.tar.gz *.pkg.tar.zst"
            done
          done

      - name: Sign APT releases
        run: |
          DEVICE="${{ inputs.device }}"
          SOURCE_DISTRO="${{ inputs.source_distro }}"
          APT_IDS=$(yq -r '.distros.apt[].id' distros.yml)

          sign_apt_repo() {
            local repo_dir="$1" label="$2" desc_prefix="$3"
            # Export GPG public key
            gpg --armor --export "AstralEmu Packages" > "${repo_dir}/astralemu.gpg"

            for distro_id in $APT_IDS; do
              DIST_DIR="${repo_dir}/dists/${distro_id}"
              [[ -d "$DIST_DIR" ]] || continue

              cd "$DIST_DIR"
              ARCH_LIST=$(ls -d main/binary-* 2>/dev/null | sed 's|main/binary-||' | tr '\n' ' ')

              cat > Release << RELEASE_EOF
          Origin: AstralEmu Packages (${label})
          Label: astralemu-${label}
          Suite: ${distro_id}
          Codename: ${distro_id}
          Architectures: ${ARCH_LIST}
          Components: main
          Description: ${desc_prefix} packages for ${distro_id}
          RELEASE_EOF

              apt-ftparchive release . >> Release
              rm -f Release.gpg InRelease
              gpg --batch --default-key "AstralEmu Packages" -abs -o Release.gpg Release
              gpg --batch --default-key "AstralEmu Packages" --clearsign -o InRelease Release
              cd "$OLDPWD"
            done
          }

          sign_apt_repo "gh-pages-dir/apt/device/${DEVICE}" "${DEVICE}" "AstralEmu ${DEVICE}"
          sign_apt_repo "gh-pages-dir/apt/deps/${SOURCE_DISTRO}" "deps-${SOURCE_DISTRO}" "AstralEmu shared dependencies (${SOURCE_DISTRO})"

      - name: Sign DNF repos
        run: |
          DEVICE="${{ inputs.device }}"
          SOURCE_DISTRO="${{ inputs.source_distro }}"

          sign_dnf_repo() {
            local repo_dir="$1" label="$2" baseurl_path="$3"
            [[ -d "$repo_dir" ]] || return 0
            gpg --armor --export "AstralEmu Packages" > "${repo_dir}/astralemu.gpg"

            find "$repo_dir" -name 'repomd.xml' | while read -r repomd; do
              rm -f "${repomd}.asc"
              gpg --batch --default-key "AstralEmu Packages" -abs \
                -o "${repomd}.asc" "$repomd"
            done

            cat > "${repo_dir}/astralemu-${label}.repo" << REPO_EOF
          [astralemu-${label}]
          name=AstralEmu Packages (${label})
          baseurl=https://astralemu.github.io/astralemu-packages/${baseurl_path}/\$releasever/\$basearch/
          enabled=1
          gpgcheck=1
          gpgkey=https://astralemu.github.io/astralemu-packages/${baseurl_path}/astralemu.gpg
          REPO_EOF
          }

          sign_dnf_repo "gh-pages-dir/dnf/device/${DEVICE}" "${DEVICE}" "dnf/device/${DEVICE}"
          sign_dnf_repo "gh-pages-dir/dnf/deps/${SOURCE_DISTRO}" "deps-${SOURCE_DISTRO}" "dnf/deps/${SOURCE_DISTRO}"

      - name: Generate landing page
        run: |
          if [[ -f intermediates-data/pages/template.html ]]; then
            pandoc README.md --from gfm --to html5 \
              --template intermediates-data/pages/template.html \
              --metadata title="AstralEmu Packages" \
              -o gh-pages-dir/index.html
          fi

      - name: Deploy to gh-pages
        run: |
          cd gh-pages-dir
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          push_with_retry() {
            for attempt in 1 2 3 4 5; do
              git push origin gh-pages && return 0
              echo "Push attempt $attempt failed, rebasing..."
              git fetch --depth=1 origin gh-pages
              git rebase origin/gh-pages
            done
            return 1
          }
          for fmt in apt dnf pacman; do
            git add "${fmt}/" || true
            if ! git diff --cached --quiet; then
              git commit -m "Update ${{ inputs.device }} ${fmt} repository"
              push_with_retry
            fi
          done
          git add -A
          if ! git diff --cached --quiet; then
            git commit -m "Update ${{ inputs.device }} index"
            push_with_retry
          fi
